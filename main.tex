\documentclass{article}

\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  backgroundcolor=\color{white},  
  basicstyle=\footnotesize,     
  breakatwhitespace=false, 
  breaklines=true,       
  captionpos=b,   
  commentstyle=\color{mygreen},  
  frame=single,	     
  keepspaces=true,
  keywordstyle=\color{blue},      
  language=Octave,                 
  numbersep=5pt,               
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\title{Mid-term paper for Programming Theory class}
\author{Ogiwara}
\date{\today}
\begin{document}

\maketitle

\section{Objective}
Pick one programming language, and explain about that.
At here, I'll explain about Pony language \cite{ponylang} through description of features and performance, sample codes, and reference capability type system, which is the key concept of this language.


\section{Features and Performance}
\subsection{Simple introduction from official page \cite{ponylang}}
Pony is an open-source, object-oriented, actor-model, capabilities-secure, high-performance programming language. \\

Pony is type safe. Really type safe. On top page, there is a link for mathematical proof paper \cite{type-proof-paper}. I will explain about that in later section. \\

Pony is memory safe. There are no dangling pointers and no buffer overruns. The language doesn't even have the concept of \texttt{null}. \\

Exception-Safe. There are no runtime exceptions. All exceptions have defined semantics, and they are always caught. \\

Data-race Free. Pony doesn’t have locks nor atomic operations or anything like that. Instead, the type system ensures at compile time that your concurrent program can never have data races. So you can write highly concurrent code and never get it wrong. \\

Deadlock-Free. This one is easy because Pony has no locks at all. So they definitely don’t deadlock, because they don’t exist.

\subsection{Example Codes}

\lstinputlisting{timer.pony}

Here is timer program in Pony.
At first sleeps for 5 seconds, and after that, repeat to run Notify.apply method in every 2 seconds.

There are \texttt{Main} actor and \texttt{Notify} class. 
\texttt{Main} actor has \texttt{new create} symbol, which works as constructor.
\texttt{Notify} class has \texttt{ \_env}, \texttt{ \_counter} fields, \texttt{create} constructor, and \texttt{apply} method.

First, \texttt{Main} actor ' \texttt{create} constructor is called. It is initial function as same as \texttt{int main()} in C or \texttt{public static void main(String[] args)} in Java. 

Values are assigned into \texttt{timers} and \texttt{timer}, and then \texttt{Timers.apply} method is called. 
At here, \texttt{Timers} is another actor, so we have to move \texttt{timer} data to the actor by \texttt{consume} expression.

 \texttt{Timers} actor calls passed object(At here \texttt{Notify})'s apply method repeatedly (At here sleeps for 5 seconds run every 2 seconds). 
 
\texttt{Notify.apply} outputs current \texttt{\_counter}, and then increment it.




\subsection{Compare to other languages}

\begin{lstlisting}[language=Erlang]{Make actor in Elixir}
defmodule Actor1 do
	def call() do
		...
	end	
end	

GenServer.start_link(Actor1, [:call])
\end{lstlisting}

To use actor, Elixir\cite{elixir} have to define module, and make actor by specifying both module name and method name.

\begin{lstlisting}{Make actor in Pony}
actor Actor1
	be call() =>
		...
		
let actor1 = Actor1		
\end{lstlisting}

However in Pony, \texttt{actor} is primitive syntax, so you can just make instance of actor as same as classes. \\



\begin{lstlisting}{ownership system in Rust}
let a = String::new("hello")
let b = a
// You can't use a at here anymore.
\end{lstlisting}

\begin{lstlisting}{consuming in Pony}
let a : String iso = "hello"
let b = consume a
// You can't use a at here anymore.
\end{lstlisting}

Pony has much more stronger reference capability type system than Rust \cite{rust} 's ownership type system. 

At here, \texttt{iso} is one of reference capability types, which mean "this value is readable in writable in one actor, and it can move to another actor".

About reference capability, I will explain about it in later section.
\\



\begin{lstlisting}[language=Python]{Python indentation}
class A:
	def b():
		...
\end{lstlisting}

\begin{lstlisting}{Pony indentation}
class A
	fun b() =>
		...
\end{lstlisting}


Pony uses indentation as block as same as Python\cite{python}.\\

\begin{lstlisting}[language=Ruby]{do end block style both in Ruby and Pony }
for i in values do
	
end		
\end{lstlisting}

 Pony uses do$\sim$end style block as same as Ruby \cite{ruby}. \\


\begin{lstlisting}[language=Java]{Type parameter and apply method in Scala}
interface A[T]{
	def apply(i: T)
}	

val a: A[Int] = new A()
a(8)
\end{lstlisting}

\begin{lstlisting}{Generics and apply method in Pony}
interface A[T]
	fun apply(i: T)
	
let a: A[Integer] = A
a(8)	
\end{lstlisting}

Pony uses square brackets([T]) for Generics, and functional style \texttt{apply} method as same as Scala\cite{scala}. \\


\begin{lstlisting}{interface in Go}
type geometry interface {
    area() float64
    perim() float64
}

type rect struct {
    width, height float64
}

func (r rect) area() float64 {
    return r.width * r.height
}
func (r rect) perim() float64 {
    return 2*r.width + 2*r.height
}
// Now type rect implements geometry interface.

\end{lstlisting}

\begin{lstlisting}{interface in Pony}
interface Animal
	fun bark(): String
	
class Dog
	fun bark(): String
		=> "Bow!"	
	
// Now type Dog implements Animal interface.
// You can annotate Dog implements Animal by 
// class Dog is Animal
\end{lstlisting}
 
Pony has structural subtyping as same as Go\cite{go}.

\section{Reference capability type system}
Combining the actor-model with shared memory for performance is efficient but can introduce data-races. Well known approaches to static data-race freedom are based on uniqueness and immutability, but lack flexibility and high performance implementations. Pony's approach, based on deny properties allow reading, writing and traversing unique references, introduced a new form of write uniqueness, and guaranteed atomic behaviours.



\begin{thebibliography}{9}
\bibitem{ponylang}
Pony language official page
\\\texttt{https://www.ponylang.io}

\bibitem{type-proof-paper}
Deny Capabilities for Safe, Fast Actors
\\\texttt{https://www.ponylang.io/media/papers/fast-cheap-with-proof.pdf}

\bibitem{elixir}
Elixir language official page
\\\texttt{https://elixir-lang.org}

\bibitem{rust}
Rust language official page
\\\texttt{https://www.rust-lang.org}

\bibitem{python}
Python language official page
\\\texttt{https://www.python.org}

\bibitem{ruby}
Ruby language official page
\\\texttt{https://www.ruby-lang.org/en/}
	
\bibitem{scala}
Scala language official page
\\\texttt{https://www.scala-lang.org}

\bibitem{go}
Go language official page
\\\texttt{https://golang.org}
	
	
\end{thebibliography}

\end{document}
